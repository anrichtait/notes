%%% Basic document setup %%%
\documentclass[12pt, letterpaper]{report}
\title{Template}
\author{Anrich Tait}
\date{\today}


%%% Packages %%%
\usepackage{graphicx}	%%% Include images
\graphicspath{{images/}}%%% Where your images are stored (relative to main file)
\usepackage{xeCJK}		%%% Include japanese/chinese/korean
\usepackage{amsmath} 	%%% Math related
\usepackage{xcolor}
\usepackage{float}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{listings}
\setCJKmainfont{Source Han Sans JP}
\setCJKsansfont{Source Han Sans JP}
\definecolor{titlepagecolor}{cmyk}{1,.60,0,.40}
\definecolor{namecolor}{cmyk}{1,.50,0,.10}
\hypersetup{colorlinks=true,linkcolor=black,filecolor=magenta,urlcolor=cyan}

\begin{document}

\begin{titlepage}
\newgeometry{left=7.5cm} %defines the geometry for the titlepage
\pagecolor{titlepagecolor}
\noindent
\color{white}
\makebox[0pt][l]{\rule{1.3\textwidth}{1pt}}
\par
\noindent
\textbf{\textsf{コース:}} \textcolor{namecolor}{\textsf{ALX Low Level Programming}}
\vfill
\noindent
{\huge \textsf{C Programming Notes}}
\vskip\baselineskip
\noindent
\textsf{作家: Anrich Tait}
\end{titlepage}
\restoregeometry % restores the geometry
\nopagecolor% Use this to restore the color pages to white

\tableofcontents

\chapter{Examples:}

\lstinputlisting[
		caption=Template Code Block, % Caption above the listing
		label=lst:template, % Label for referencing this listing
		language=C, % Specificies language in the block
		frame=single, % Frame around the code listing
		showstringspaces=false, % Don't put marks in string spaces
		numbers=left, % Line numbers on left
		numberstyle=\tiny, % Line numbers styling
	]{template.c}
	This is a very basic example of how code blocks will look in the document.


\chapter{Functions}
\section{Outline:}
	The following questions/topics will be addressed:
	\begin{enumerate}
		\item What are functions?
		\item How are functions utilised?
		\item Examples of using functions.
	\end{enumerate}

\section{Definition}
Functions break large computing tasks into smaller ones. This helps make code 
easier to change in the future and can also help  with readability. Appropriate 
functions also hide details of operations from parts of the program that don't 
need them. C programs generally consist of many small functions rather than fewer 
large ones. The most basic example of a function is main(), every program has one 
and it is executed before any other functions in the program. Functions can be 
used for any task but generally it is best for each function to accomplish a 
specific task. A function declaration provides the actual body of the function. \\

The standard library provides numerous builtin functions that your program can call
for example:
\begin{enumerate}
	\item strcat() to concatenate strings
	\item memcpy() to copy the memory location of one parameter to another.
\end{enumerate}

\section*{A FUNCtional example:}
	\lstinputlisting[
		caption=Example of calling a function in C,
		label=Functions Example 1, % Label for referencing this listing
		language=C, % Specificies language in the block
		frame=single, % Frame around the code listing
		showstringspaces=false, % Don't put marks in string spaces
		numbers=left, % Line numbers on left
		numberstyle=\tiny, % Line numbers styling
	]{functions1.c}

The above example gives the user two choices and then asks for input. based on
the input a specified function is called to output the relevant text. While the 
use of functions is explicitly necessary in this example it shows how code can be
broken up into smaller blocks, each with a specific purpose.

\clearpage
\section{Defining a function}

\subsection*{Syntax:}
\begin{lstlisting}
	return_type function_name(parameter list)
	{
		body of function
	}
\end{lstlisting}

Here is a break down of each part of this syntax:

\begin{enumerate}
	\item return\_type: The type of value the function will return.
	\item function\_name: Name of the function.
	\item (parameter list): list of parameters passed to the function.
	\item body of function: code to be executed
\end{enumerate}

Example:
\begin{lstlisting}
	int add(int a, int b)
	{
		int result = a + b;
		return (result);
	}
\end{lstlisting}
 
Break down:
\begin{enumerate}
	\item int: Return type of function (integer).
	\item add: Name of function.
	\item (int a, int b)\: parameters.
	\item int result \= a + b: declare result variable and code that will be executed.
	\item return (result)\: returns the value of the result variable.
\end{enumerate}

\textbf{Note:} if a function does not return anything it can be specified as void.

Functions can be called from other parts of a program by using the function name 
and passing in the required parameters.

\begin{lstlisting}
	int x = 5;
	int y = 7;

	int z = add(x, y);
\end{lstlisting}
The function 'add' is called with x and y as the parameters. The x parameter 
will replace 'a' and 'y' will replace 'b'. The result is stored in 'z'.


\section{Function types}

\begin{enumerate}
	\item Functions that return a value:
		Perform a specific task and return a value of a specific data type using 
		the return statement. The previous "add" function is an example of this.
	\begin{lstlisting}
		char get_first_char(char *str)
		{
			return[0];
		}
	\end{lstlisting}
	\item Functions that return nothing:
	Perform a task but does not return any value.
	\begin{lstlisting}
		void print_hello()
		{
			printf("Hello, world!")
		}
	\end{lstlisting}
	\item Functions that take no parameters:
		Does not take any paramters but perfomrs a specific task.
	\begin{lstlisting}
		void clear_screen()
		{
			system("clear");
		}
	\end{lstlisting}
	\item Functions that take parameters but return nothing.
	\begin{lstlisting}
		void greet(char *name)
		{
			printf("Hello, %s", name);
		}
	\end{lstlisting}
\end{enumerate}


\section{Calling a function}
When a function is called, control of the program is transferred to the function
until it's return statement or closing brace is reached. Then the main() 
function is used again.\\

To call a function you need to pass the required parameters.\\

Passing parameters to a function basically means providing values or variables
to the function.

Going back to the 'add' function as an example. \\
x and y are the parameters that are passed to the function. When the function is
called with arguments the values of the arguments are assigned to the corresponding
parameters. So if we call the 'add' function with arguments 3 and 4 the values
3 and 4 are assigned to x and y respectively.\\

\clearpage
\section{Function arguments}
For a function to use arguments it must declare variables that accept the values
of the arguments. These variables are called the formal parameters of a function.

Formal parameters behave like other local variables and are created upon entry
to the function and are destroyed upon exit.

There are two ways arguments can be passed to a function:

\subsection{Call/Pass by value:}
The function receives a copy of the argument passed, not the original argument.
So any changes made to the argument inside the function do not change the original
value of the argument.
		
	\lstinputlisting[
		caption=Call by value example, % Caption above the listing
		language=C, % Specificies language in the block
		frame=single, % Frame around the code listing
		showstringspaces=false, % Don't put marks in string spaces
		numbers=left, % Line numbers on left
		numberstyle=\tiny, % Line numbers styling
	]{functions3.c}
	In this example the 'increment' function takes an integer argument ('x') 
	and then increments it by one. The following main function calls the 
	increment function and passes "num" to it. This does not change the output 
	as the increment function does not change the original value "num".


\subsection{Call/Pass by reference:}
Calling a function by reference involves passing arguments to a function using
the parameters address. This way the actual value is changed, not just a copy
of it.\\

To pass a variable by reference in C, you must declare the function parameter 
as a pointer type using the * operator.\\


The following example function takes a pointer to an integer as a parameter.

	\lstinputlisting[
		caption=Call by reference example, % Caption above the listing
		language=C, % Specificies language in the block
		frame=single, % Frame around the code listing
		showstringspaces=false, % Don't put marks in string spaces
		numbers=left, % Line numbers on left
		numberstyle=\tiny, % Line numbers styling
	]{functions4.c}

\textbf{Note:} by default C passes arguments by value.
\clearpage


\section{Function Prototypes}

\subsection{What is a function prototype}
A function prototype is a declaration of a function that describes the function's
interface to the rest of the program. It specifies the function's name, return
type and parameter types.\\

These are usually specified at the beginning of a file before any other functions.

\subsection*{Syntax:}
\begin{lstlisting}
	return_type function_name(parameter_list);
\end{lstlisting}

For example:
\begin{lstlisting}
	int max(int numOne, int numTwo);
\end{lstlisting}
This prototype declares a funtion named max that takes two integer parameters.

\subsection{Why are function prototypes used?}

\begin{enumerate}
	\item Type checking: By declaring the function prototype before calling the 
		function the compiler can check that the arguments passed to the function 
		match the expected types.
	\item Avoid implicit declaration: If a function is not given an implicit type 
		the compiler assumes it is an integer, this can lead to misleading errors 
		relating to different return types or number of arguments.
	\item Optimization: Allows the compiler to generate more efficient code by
		providing information about the function's interface. This can lead to
		smaller, faster code.
	\item Documentation: Can server as documentation for the function, making
		it easier for other programmers to understand how to use a function.
\end{enumerate}

\chapter{Pointers}

	\subsection*{Syntax:}
	<type> *<name>

\vspace{0.25cm}

\begin{enumerate}
	\item type = is the data type that the pointer will point to.
	\item name = is the name of the pointer variable.
\end{enumerate}


\subsection*{Example:}
To declare a pointer variable that will point to an integer value the 
following syntax is used,
\begin{lstlisting}
	int *ptr;
\end{lstlisting}
This declares a pointer variable named "ptr" that can point to an integer 
value.\\

To assign  a value to a pointer variable the address-of operator (\&) is used 
to get the memory address of the variable.\\

\subsection*{Example:}
Assign the address of an intger variable named "x" to the pointer variable 
"ptr",
\begin{lstlisting}
	int x = 10;
	int *ptr = &x;
\end{lstlisting}
This assigns the address of "x" to "ptr", so now "ptr" points to x.
To access the value that is stored at the memory location pointed to by a
pointer variable the dereference operator is used (*).\\

\section{Concept}
Pointers are a fundamental concept in the C programming language, 
and understanding how they work is essential for writing efficient and 
effective C code. A pointer is a variable that stores the memory address of 
another variable. By using pointers, C programs can directly access and 
manipulate the values of other variables in memory, providing a powerful tool 
for building complex data structures and optimizing program performance.\\

At its core, a pointer is simply a memory address. When you declare a pointer 
variable in C, you are creating a variable that can store the address of 
another variable in memory. To declare a pointer variable, you use the * 
symbol before the variable name, like this: int *ptr;. This declares a pointer
variable named ptr that can store the memory address of an integer variable.\\

Once you have declared a pointer variable, you can use the \& operator to get 
the memory address of another variable, and assign that address to the pointer
variable using the assignment operator =. For example, if you have an integer 
variable named x, you can get its memory address with \&x, and assign it to the 
pointer variable ptr like this: ptr = \&x;. Now, ptr points to the memory 
location of x, and you can use the pointer to access and manipulate the value 
of x directly.\\

One of the most common uses of pointers in C is to pass variables by 
reference to functions. In C, when you pass a variable to a function as an 
argument, the function gets a copy of the variable's value. However, by 
passing the memory address of the variable instead, you can allow the function 
to directly access and modify the variable's value. This can be useful for 
functions that need to modify variables outside of their own scope.\\

Another important use of pointers in C is for dynamic memory allocation. In C,
you can use the malloc() function to allocate a block of memory of a specified 
size at runtime. The malloc() function returns a pointer to the beginning of 
the allocated memory block, which you can then use to access and manipulate 
the memory. Once you are done with the memory, you should free it using the 
free() function to avoid memory leaks.\\

Pointers can also be used to create complex data structures in C, such as 
linked lists, trees, and graphs. By using pointers to connect nodes together 
in these structures, you can create efficient and flexible data structures 
that can be easily traversed and manipulated.\\

However, while pointers are a powerful tool in C programming, they can also be
dangerous if used improperly. Pointer errors, such as dereferencing a null 
pointer or accessing memory that has already been freed, can cause program 
crashes or even security vulnerabilities. To avoid these errors, it is 
important to carefully manage and validate pointers in your code, and to use 
best practices for pointer manipulation, such as initializing pointers to null
and checking for null before dereferencing them.\\

In conclusion, pointers are a fundamental concept in C programming that allow 
you to directly access and manipulate the values of variables in memory. 
Pointers are used extensively in C for passing variables by reference, 
dynamic memory allocation, and creating complex data structures. While 
pointers can be a powerful tool, they can also be dangerous if used improperly,
and it is important to carefully manage and validate pointers in your code to 
avoid errors and vulnerabilities.\\


\subsection*{Summary:}
The syntax for a pointer consists of the data type followed by an asterisk
and the name of the pointer variable. The address-of operator (\&) is used 
to assign a value to the pointer, and the dereference operator (*) is 
used to access the value stored at the memory location pointed to by the 
pointer.

\newpage
\section{Examples}

\subsection{How to use pointers:}

	\lstinputlisting[
		caption=Pass variables by reference to functions:,
		language=C, % Use Perl functions/syntax highlighting
		frame=single, % Frame around the code listing
		showstringspaces=false, % Don't put marks in string spaces
		numbers=left, % Line numbers on left
		numberstyle=\tiny, % Line numbers styling
		]{how-to-pointers1.c}
In this example, swap() is a function that takes two integer pointers as 
arguments and swaps their values. By passing the memory addresses of a and b 
to swap() using the \& operator, we allow the function to directly modify the 
values of a and b.

\clearpage
	\lstinputlisting[
		caption=Allocate memory dynamically:
		language=C, % Use Perl functions/syntax highlighting
		frame=single, % Frame around the code listing
		showstringspaces=false, % Don't put marks in string spaces
		numbers=left, % Line numbers on left
		numberstyle=\tiny, % Line numbers styling
	]{how-to-pointers2.c}
In this example, we use the malloc() function to dynamically allocate an array 
of 10 integers, and store its memory address in the pointer variable arr. We 
then use a loop to assign the values 0 to 9 to the array elements. Finally, we
use the free() function to release the allocated memory.


































\end{document}
